/**
 * @file bg_sub.cpp
 * @brief Background subtraction
 * @author Pepe Donato
 */

//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include "videoInput.h" // video input library include file

//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include <vector>


using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

//function declarations
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

void help()
{
  cout
  << "--------------------------------------------------------------------------"  << endl
  << "This program by Pepe Donato show to use Computer Vison"   << endl
  << "You can process both videos or webcam (-vid) and images (-img)."              << endl
                                                                                   << endl
  << "Usage:"                                                                      << endl
  << "{-vid <video filename>|-img <image filename>}"                          << endl
  << "for example: -vid video.avi"                                            << endl
  << "for default webcam: -vid 0"                                            << endl 
  << "or: -img /data/images/1.png"                                            << endl
  << "--------------------------------------------------------------------------"  << endl
  << "Esc or q for exit, and + or - for learning rate"                                << endl

  << endl;
}

int main(int argc, char* argv[])
{
  //print help information
  help();

  //check for the input parameter correctness
  if(argc != 3) {
    cerr <<"Incorret input list" << endl;
    cerr <<"exiting..." << endl;
    return EXIT_FAILURE;
  }

  //create GUI windows
  namedWindow("Frame");
  //namedWindow("FG Mask MOG");
  //namedWindow("FG Mask MOG 2");

  //create Background Subtractor objects
  pMOG = createBackgroundSubtractorMOG2(); //MOG approach
  pMOG2 = createBackgroundSubtractorMOG2(0.2, 0, true); //MOG2 approach

  if(strcmp(argv[1], "-vid") == 0) {
    //input data coming from a video
    processVideo(argv[2]);
  }
  else if(strcmp(argv[1], "-img") == 0) {
    //input data coming from a sequence of images
    processImages(argv[2]);
  }
  else {
    //error in reading input parameters
    cerr <<"Please, check the input parameters." << endl;
    cerr <<"Exiting..." << endl;
    return EXIT_FAILURE;
  }
  //destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
  //create the capture object
	videoInput::listDevices();		// get list of devices
	videoInput * vi = new videoInput();   	//required class to manage all the cameras
	IplImage* img;

	bool webcam = false;
	VideoCapture capture(videoFilename);
	if(!capture.isOpened()){
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << ", try webcam" << endl;
		std::string::size_type sz;   // alias of size_t
		 int i_dec = std::stoi (videoFilename,&sz);

		vi->setupDevice(i_dec);			// choose first device (device 0)

		// if  isn't OK with device 0
	
 		if(!(vi->isDeviceSetup(i_dec)))
		{

		 /*
		VideoCapture capture(i_dec);
		if(!capture.isOpened()){
		*/
			//error in opening the video input
			cerr << "Unable to open webcam " << endl;
			exit(EXIT_FAILURE);
		}
		webcam = true;
		img = cvCreateImage(cvSize(vi->getWidth(0),vi->getHeight(0)),8, 3);
	}

  std::vector<std::vector<cv::Point> > contours;
  bool frameok;
  double learningrate = -1;
  cout << " Learning rate = " << learningrate << " auto" << endl;
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
 
	keyboard = waitKey( 30 );
	if ((char)keyboard == '+' && learningrate <=1){
		if (learningrate <0) { 
				learningrate = 0;
		} else {
			learningrate = learningrate + 0.05;
		}
		cout << " Learning rate = " << learningrate << endl;
	}
	if ((char)keyboard == '-' && learningrate >=-1) {
		if (learningrate <0) { 
				learningrate = 0;
		} else {
			learningrate = learningrate - 0.05;
		}
		cout << " Learning rate = " << learningrate << endl;
	}
    //read the current frame
	/*
    if(!capture.read(frame)) {if(!capture.read(frame)) {if(!capture.read(frame)) {if(!capture.read(frame)) {
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
     // exit(EXIT_FAILURE);
	}}}}
	*/
	if (webcam){
		if(vi->isFrameNew(0))
		{
			frameok = true;
			
			// get the pixels from the image to the "imageData" of the OpenCV
			// image (here we assign it's an 8-bit 3 channel image
			
			// BGR order, flipped (=> do not requrie flipping or origin fixes)

			// N.B. This is a data "copy", see getPixels() doc. for info.

			vi->getPixels(0,(unsigned char*)img->imageData,false,true); 

			frame = cv::cvarrToMat(img);  // default additional arguments: don't copy data.
		} else
		{
			frameok = false;
		}

	}else{
		frameok = capture.read(frame);
		
	}


	if(frameok) {
    //update the background model
    pMOG->apply(frame, fgMaskMOG, learningrate);
    pMOG2->apply(frame, fgMaskMOG2, learningrate);

	if (!webcam){
		//get the frame number and write it on the current frame
	    stringstream ss;
	    rectangle(frame, cv::Point(10, 2), cv::Point(100,20), cv::Scalar(255,255,255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
	}
	cv::erode(fgMaskMOG,fgMaskMOG,cv::Mat());
    cv::dilate(fgMaskMOG,fgMaskMOG,cv::Mat());
    cv::findContours(fgMaskMOG,contours,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_NONE);
    cv::drawContours(frame,contours,-1,cv::Scalar(0,0,255),2);


    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("Mask + Erode + Dilate -> Contours", fgMaskMOG);
    imshow("Mask", fgMaskMOG2);
    //get the input from the keyboard
    
	} else{
		//cerr << "Unable to read next frame." << endl;
	}
  }
  //delete capture object
  capture.release();
  
}

void processImages(char* fistFrameFilename) {
  //read the first file of the sequence
  frame = imread(fistFrameFilename);
  if(!frame.data){
    //error in opening the first image
    cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
    exit(EXIT_FAILURE);
  }
  //current image filename
  string fn(fistFrameFilename);
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    //update the background model
    pMOG->apply(frame, fgMaskMOG);
    pMOG2->apply(frame, fgMaskMOG2);
    //get the frame number and write it on the current frame
    size_t index = fn.find_last_of("/");
    if(index == string::npos) {
      index = fn.find_last_of("\\");
    }
    size_t index2 = fn.find_last_of(".");
    string prefix = fn.substr(0,index+1);
    string suffix = fn.substr(index2);
    string frameNumberString = fn.substr(index+1, index2-index-1);
    istringstream iss(frameNumberString);
    int frameNumber = 0;
    iss >> frameNumber;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
              cv::Scalar(255,255,255), -1);
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("Mask", fgMaskMOG);
    imshow("Mask", fgMaskMOG2);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
    //search for the next image in the sequence
    ostringstream oss;
    oss << (frameNumber + 1);
    string nextFrameNumberString = oss.str();
    string nextFrameFilename = prefix + nextFrameNumberString + suffix;
    //read the next frame
    frame = imread(nextFrameFilename);
    if(!frame.data){
      //error in opening the next image in the sequence
      cerr << "Unable to open image frame: " << nextFrameFilename << endl;
      exit(EXIT_FAILURE);
    }
    //update the path of the current frame
    fn.assign(nextFrameFilename);
  }
}